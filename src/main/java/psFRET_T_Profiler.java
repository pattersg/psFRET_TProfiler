/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import ij.*;
import ij.plugin.*;
import ij.plugin.filter.Analyzer;
import ij.process.*;
import ij.gui.*;
import ij.util.Tools;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import ij.measure.*;
import java.awt.Rectangle;


import ij.WindowManager;

import ij.plugin.frame.RoiManager;

import java.io.IOException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.awt.event.ItemEvent;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import loci.common.services.ServiceFactory;
import loci.formats.IFormatReader;
import loci.formats.ImageReader;
import loci.formats.meta.IMetadata;
import loci.formats.services.OMEXMLService;

import ome.units.quantity.Time;
import ome.units.UNITS;
/**
 *
 * @author pattersg
 */
public class psFRET_T_Profiler extends javax.swing.JFrame implements PlugIn, MouseListener, MouseMotionListener, Measurements, KeyListener, ActionListener, PropertyChangeListener, WindowListener {
ImagePlus img;
    ImageCanvas canvas;
    ImageStatistics stats;
    PlotWindow pwin;
    PlotWindow pwin2;
    public double[] y;
    public double[] x;
    String xLabel;
    String yLabel;
    boolean listenersRemoved;
    boolean isSelection;
    private static int numCycles;
    private static int imagesPerCycle;
    private static boolean fitCurves;
    private static boolean bkGrdSubtract;
    private static boolean ProfilingOn;
    private static boolean saveResultsToTable;
    private static String bkGrdImage;
    private static boolean dialogCanceled;
    private static boolean profileGet;
    private static boolean pluginWindowOpen;
    private static int estimateS2;

    RoiManager rMan;
    ResultsTable rt;
    DefaultComboBoxModel dataListModel;
    Vector dataList = new Vector();
    /**
     * Creates new form psFRET_T_Profiler
     */
    public psFRET_T_Profiler() {
        initComponents();
        dataList.add("None");
        dataListModel = new DefaultComboBoxModel(dataList);
        comboBoxDataList.setModel(dataListModel);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        getProfile = new javax.swing.JButton();
        numCyclesTF = new javax.swing.JTextField();
        imagesPerCycleTF = new javax.swing.JTextField();
        numCycleText = new javax.swing.JLabel();
        imagesPerCycleText = new javax.swing.JLabel();
        checkCF = new javax.swing.JCheckBox();
        checkProfilingOn = new javax.swing.JCheckBox();
        writeToResults = new javax.swing.JButton();
        checkBkg = new javax.swing.JCheckBox();
        bkGrdText = new javax.swing.JLabel();
        jPanel1 = new javax.swing.JPanel();
        comboBoxDataList = new javax.swing.JComboBox<>();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("psFRET T Profiler");

        getProfile.setText("Get Profile");
        getProfile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getProfileActionPerformed(evt);
            }
        });

        numCyclesTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        numCyclesTF.setText("3");
        numCyclesTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                numCyclesTFActionPerformed(evt);
            }
        });
        numCyclesTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                numCyclesTFPropertyChange(evt);
            }
        });

        imagesPerCycleTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        imagesPerCycleTF.setText("300");
        imagesPerCycleTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imagesPerCycleTFActionPerformed(evt);
            }
        });
        imagesPerCycleTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                imagesPerCycleTFPropertyChange(evt);
            }
        });

        numCycleText.setText("Number of Cycles");

        imagesPerCycleText.setText("Images per Cycle");

        checkCF.setText("Run curve fits?");
        checkCF.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkCFItemStateChanged(evt);
            }
        });
        checkCF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkCFActionPerformed(evt);
            }
        });

        checkProfilingOn.setText("Turn on dynamic profiling?");
        checkProfilingOn.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkProfilingOnItemStateChanged(evt);
            }
        });
        checkProfilingOn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkProfilingOnActionPerformed(evt);
            }
        });

        writeToResults.setText("Write to Results");
        writeToResults.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                writeToResultsActionPerformed(evt);
            }
        });

        checkBkg.setText("Background subtract?");
        checkBkg.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkBkgItemStateChanged(evt);
            }
        });

        bkGrdText.setText("Choose the background data");

        comboBoxDataList.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        comboBoxDataList.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                comboBoxDataListItemStateChanged(evt);
            }
        });

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addContainerGap(29, Short.MAX_VALUE)
                .addComponent(comboBoxDataList, javax.swing.GroupLayout.PREFERRED_SIZE, 228, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(comboBoxDataList, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap(27, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkCF)
                            .addComponent(checkBkg)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(numCycleText)
                                    .addComponent(imagesPerCycleText))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.DEFAULT_SIZE, 69, Short.MAX_VALUE)
                                    .addComponent(numCyclesTF)))))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(44, 44, 44)
                        .addComponent(bkGrdText))
                    .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(52, 52, 52)
                        .addComponent(writeToResults))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(73, 73, 73)
                        .addComponent(getProfile))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(35, 35, 35)
                        .addComponent(checkProfilingOn)))
                .addContainerGap(18, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(30, 30, 30)
                .addComponent(getProfile)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(numCycleText))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleText)
                    .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(40, 40, 40)
                .addComponent(checkCF)
                .addGap(36, 36, 36)
                .addComponent(checkBkg)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(bkGrdText)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(checkProfilingOn)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 37, Short.MAX_VALUE)
                .addComponent(writeToResults)
                .addGap(26, 26, 26))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void getProfileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getProfileActionPerformed
        numCycles = Integer.parseInt(numCyclesTF.getText());
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        img = WindowManager.getCurrentImage();
        profileGet = true;
        ImageProcessor ip2 = img.getProcessor();
        runIP(ip2);
    }//GEN-LAST:event_getProfileActionPerformed

    private void numCyclesTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_numCyclesTFActionPerformed
        numCycles = Integer.parseInt(numCyclesTF.getText());
    }//GEN-LAST:event_numCyclesTFActionPerformed

    private void imagesPerCycleTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imagesPerCycleTFActionPerformed
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
    }//GEN-LAST:event_imagesPerCycleTFActionPerformed

    private void checkCFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkCFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkCFActionPerformed

    private void checkProfilingOnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkProfilingOnActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkProfilingOnActionPerformed

    private void writeToResultsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_writeToResultsActionPerformed
        img = WindowManager.getCurrentImage();
        saveResultsToTable = true;
        profileGet = true;
        ImageProcessor ip3 = img.getProcessor();
        runIPandSave(ip3);
    }//GEN-LAST:event_writeToResultsActionPerformed

    private void numCyclesTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_numCyclesTFPropertyChange
        numCycles = Integer.parseInt(numCyclesTF.getText());
    }//GEN-LAST:event_numCyclesTFPropertyChange

    private void imagesPerCycleTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_imagesPerCycleTFPropertyChange
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
    }//GEN-LAST:event_imagesPerCycleTFPropertyChange

    private void checkCFItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkCFItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitCurves = true;
        } else {
            fitCurves = false;
        }
    }//GEN-LAST:event_checkCFItemStateChanged

    private void checkBkgItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkBkgItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            rt = Analyzer.getResultsTable();
            String[] tableHeadings = rt.getHeadings();
            for (int th = 0; th < tableHeadings.length; th++) {
                if (dataListModel.getIndexOf(tableHeadings[th]) == -1) {
                    dataListModel.addElement(tableHeadings[th]);
                }
            }
            if (tableHeadings.length == 0) {
                IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table\nPlease use the 'Write To Results' button and try again");
                checkBkg.setSelected(false);
                return;
            }else{
            bkGrdSubtract = true;
            }
        } else {
            dataListModel.removeAllElements();
            dataListModel.addElement("None");
            bkGrdSubtract = false;
        }
    }//GEN-LAST:event_checkBkgItemStateChanged

    private void comboBoxDataListItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_comboBoxDataListItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            String bkGrdImageCB = (String) evt.getItem();
            bkGrdImage = bkGrdImageCB;
        }
    }//GEN-LAST:event_comboBoxDataListItemStateChanged

    private void checkProfilingOnItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkProfilingOnItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            ProfilingOn = true;
        } else {
            ProfilingOn = false;
        }
    }//GEN-LAST:event_checkProfilingOnItemStateChanged

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new psFRET_T_Profiler().setVisible(true);
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel bkGrdText;
    private javax.swing.JCheckBox checkBkg;
    private javax.swing.JCheckBox checkCF;
    private javax.swing.JCheckBox checkProfilingOn;
    private javax.swing.JComboBox<String> comboBoxDataList;
    private javax.swing.JButton getProfile;
    private javax.swing.JTextField imagesPerCycleTF;
    private javax.swing.JLabel imagesPerCycleText;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JLabel numCycleText;
    private javax.swing.JTextField numCyclesTF;
    private javax.swing.JButton writeToResults;
    // End of variables declaration//GEN-END:variables
   
    public void runIP(ImageProcessor ip) {
        if (dialogCanceled) {
            return;
        }
        ImagePlus img = WindowManager.getCurrentImage();
        this.img = img;
        if (img.getStackSize() < 2) {
            IJ.showMessage("psFRET T Profiler", "This command requires a stack.");
            return;
        }
        isSelection();
        if (!isSelection) {
            IJ.showMessage("psFRET T Profiler", "Selection required. Please make an ROI on the image.");
            return;
        }
        String filePath = IJ.getDirectory("image");
        String name = img.getTitle();
        String id = filePath + name;
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        if (numCycles * imagesPerCycle > size) {
            IJ.showMessage("psFRET T Profiler", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
        if (bkGrdSubtract && "None".equals(bkGrdImage)) {
            IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table\nPlease use the 'Write To Results' button and try again");
            return;
        }
        double[] timeData = new double[size];
        try {
            timeData = getTimingPerPlane(id, size, currentZ, currentchannel);
        } catch (Exception e) {
            e.printStackTrace();
        }
        IJ.resetMinAndMax(img);
        rMan = RoiManager.getRoiManager();
        ImageWindow win = img.getWindow();
        win.addWindowListener(win);
        canvas = win.getCanvas();
        canvas.addMouseListener(this);
        canvas.addMouseMotionListener(this);
        canvas.addKeyListener(this);
        Roi roi = img.getRoi();
        y = getTAxisProfile();
        if (y != null) {
            x = new double[y.length];
            Calibration cal = img.getCalibration();
            for (int i = 0; i < x.length; i++) {
                x[i] = timeData[i];
            }
            xLabel = cal.getTimeUnit();
            yLabel = cal.getValueUnit();
            updateProfile(x, y);
            profileGet = false;
            positionPlotWindow();
        }
    }

    public void runIPandSave(ImageProcessor ip) {
        if (dialogCanceled) {
            return;
        }
        img = WindowManager.getCurrentImage();
        this.img = img;
        if (img.getStackSize() < 2) {
            IJ.showMessage("psFRET T Profiler", "This command requires a stack.");
            return;
        }
        String filePath = IJ.getDirectory("image");
        String name = img.getTitle();
        String id = filePath + name;
        String ROIName = "";
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        if (numCycles * imagesPerCycle > size) {
            IJ.showMessage("psFRET T Profiler", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
        if (bkGrdSubtract && "None".equals(bkGrdImage)) {
            IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
            return;
        }
        double[] timeData = new double[size];
        try {
            timeData = getTimingPerPlane(id, size, currentZ, currentchannel);
        } catch (Exception e) {
            e.printStackTrace();
        }
        IJ.resetMinAndMax(img);

        rMan = RoiManager.getRoiManager();
        if (rMan.getCount() == 0) {
            IJ.showMessage("psFRET T Profiler", "You must add at least one ROI to the ROI Manager to set results to the results table");
            return;
        }
        rMan.runCommand("Select All");
        rMan.runCommand("Save", filePath + name.substring(0, name.indexOf(".")) + "_RoiSet.zip");
        Roi[] roiArray = rMan.getRoisAsArray();
        for (int r = 0; r < roiArray.length; r++) {
            int roiIndex = rMan.getRoiIndex(roiArray[r]);
            rMan.select(img, roiIndex);
            ROIName = rMan.getName(roiIndex);
            Roi roi = img.getRoi();
            y = getTAxisProfile();
            if (y != null) {
                x = new double[y.length];
                Calibration cal = img.getCalibration();
                for (int i = 0; i < x.length; i++) {
                    x[i] = timeData[i];
                }
                xLabel = cal.getTimeUnit();
                yLabel = cal.getValueUnit();
                updateProfileAndResults(x, y, ROIName);
                profileGet = false;
                positionPlotWindow();
            }
        }
    }

    double[] getTAxisProfile() {
        ImageStack stack = img.getStack();
        Roi roi = img.getRoi();
        if (roi == null) {
            return null;
        }
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        double[] values = new double[size];
        Rectangle r = roi.getBoundingRect();
        Calibration cal = img.getCalibration();
        //ROI with Area > 0
        img.setC(currentchannel + 1);
        for (int i = 1; i <= size; i++) {
            if (img.getNFrames() == 1) {
                img.setZ(i);
            } else {
                img.setT(i);
            }
            ImageProcessor ip = img.getProcessor();
            ip.setRoi(roi);
            ImageStatistics stats = ImageStatistics.getStatistics(ip, MEAN, cal);
            values[i - 1] = (double) stats.mean;
        }
        if (img.getNFrames() == 1) {
            img.setZ(1);
        } else {
            img.setT(1);
        }
        double[] extrema = Tools.getMinMax(values);
        if (Math.abs(extrema[1]) == Double.MAX_VALUE) {
            return null;
        } else {
            return values;
        }
    }

    void positionPlotWindow() {
        IJ.wait(500);
        if (pwin == null || img == null) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension plotSize = pwin.getSize();
        Dimension imageSize = iwin.getSize();
        if (plotSize.width == 0 || imageSize.width == 0) {
            return;
        }
        Point imageLoc = iwin.getLocation();
        int w = imageLoc.x + imageSize.width + 10;
        if (w + plotSize.width > screen.width) {
            w = screen.width - plotSize.width;
        }
        pwin.setLocation(w, imageLoc.y);
        iwin.toFront();
    }

    public void mouseReleased(MouseEvent e) {
        checkPlotWindow();
        if (pwin != null && ProfilingOn) {
            y = getTAxisProfile();
            updateProfile(x, y);
        }
    }

    void updateProfile(double[] x, double[] y) {
        ImageStack stack = img.getStack();
        isSelection();
        if (!isSelection) {
            return;
        }
        checkPlotWindow();
        if (profileGet || ProfilingOn) {
            listenersRemoved = false;
        } else if (pwin == null || listenersRemoved || y == null || y.length == 0 || !ProfilingOn || !pluginWindowOpen) {
            return;
        }
        String name = img.getTitle();
        int ch = img.getC();
        int zPos = img.getZ();
        int n = img.getNFrames();
        Plot plot = new Plot("profile", xLabel, yLabel);
        double ymin = ProfilePlot.getFixedMin();
        double ymax = ProfilePlot.getFixedMax();
        if (!(ymin == 0.0 && ymax == 0.0)) {
            double[] a = Tools.getMinMax(x);
            double xmin = a[0];
            double xmax = a[1];
            plot.setLimits(xmin, xmax, ymin, ymax);
        }
        if (!fitCurves) {
            plot.add("circles", x, y);
        }
        if (fitCurves) {
            if (bkGrdSubtract) {
                if ("None".equals(bkGrdImage) || bkGrdImage == null) {
                    IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
                    return;
                }
                rt = Analyzer.getResultsTable();
                double[] y2 = new double[y.length];
                for (int bkg = 0; bkg < y.length; bkg++) {
                    y2[bkg] = y[bkg] - rt.getValue(bkGrdImage, bkg);
                }
                y = y2;
            }
            plot.add("circles", x, y);
            double[] yResiduals = new double[y.length];
            for (int cycle = 0; cycle < numCycles; cycle++) {
                double[] x4Fit = Arrays.copyOfRange(x, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[] x4FitZerod = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    x4FitZerod[j] = x4Fit[j] - x4Fit[0];
                }
                double[] y4Fit = Arrays.copyOfRange(y, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[][][] fitAndPara = updateCurveFit(x4FitZerod, y4Fit);
                double[] yFitted = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    yFitted[j] = fitAndPara[0][j][0];
                    yResiduals[(cycle * imagesPerCycle) + j] = fitAndPara[2][0][j];
                }
                plot.add("line", x4Fit, yFitted);
                String labelToAddA = "A=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                String labelToAddK = "k=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                String labelToAddC = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][4][0] * 1000) / 1000);
                plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA);
                plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK);
                plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddC);
                plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddChi2);
            }
            //residuals plot
            Plot plotResiduals = new Plot("residuals", xLabel, yLabel);
            plotResiduals.add("circles", x, yResiduals);
            if (pwin2 == null) {
                pwin2 = plotResiduals.show();
            } else {
                pwin2.drawPlot(plotResiduals);
            }
        }
        if (pwin == null) {
            pwin = plot.show();
        } else {
            pwin.drawPlot(plot);
        }
    }

    void updateProfileAndResults(double[] x, double[] y, String nameROI) {
        double[] yOrig = y;
        ImageStack stack = img.getStack();
        isSelection();
        if (!isSelection) {
            return;
        }
        checkPlotWindow();
        if (profileGet || ProfilingOn) {
            listenersRemoved = false;
        } else if (listenersRemoved || y == null || y.length == 0 || !pluginWindowOpen) {
            return;
        }
        String name = img.getTitle();
        int ch = img.getC();
        int zPos = img.getZ();
        int n = img.getNFrames();
        Plot plot = new Plot("profile", xLabel, yLabel);
        double ymin = ProfilePlot.getFixedMin();
        double ymax = ProfilePlot.getFixedMax();
        if (!(ymin == 0.0 && ymax == 0.0)) {
            double[] a = Tools.getMinMax(x);
            double xmin = a[0];
            double xmax = a[1];
            plot.setLimits(xmin, xmax, ymin, ymax);
        }
        if (!fitCurves) {
            plot.add("circles", x, y);
        }
        String roiColumnName = "Rois";
        String aColumnName = "a_from_fit";
        String bColumnName = "k_from_fit";
        String cColumnName = "offset_from_fit";
        String Chi2ColumnName = "Chi2_from_fit";
        if (fitCurves) {
            if (bkGrdSubtract) {
                if ("None".equals(bkGrdImage) || bkGrdImage == null) {
                    IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
                    return;
                }
                rt = Analyzer.getResultsTable();
                double[] y2 = new double[y.length];
                for (int bkg = 0; bkg < y.length; bkg++) {
                    y2[bkg] = y[bkg] - rt.getValue(bkGrdImage, bkg);
                }
                y = y2;
            }
            plot.add("circles", x, y);
            double[] yResiduals = new double[y.length];
            for (int cycle = 0; cycle < numCycles; cycle++) {
                double[] x4Fit = Arrays.copyOfRange(x, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[] x4FitZerod = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    x4FitZerod[j] = x4Fit[j] - x4Fit[0];
                }
                double[] y4Fit = Arrays.copyOfRange(y, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[][][] fitAndPara = updateCurveFit(x4FitZerod, y4Fit);
                double[] yFitted = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    yFitted[j] = fitAndPara[0][j][0];
                    yResiduals[(cycle * imagesPerCycle) + j] = fitAndPara[2][0][j];
                }
                plot.add("line", x4Fit, yFitted);
                String labelToAddA = "A=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                String labelToAddK = "k=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                String labelToAddC = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][4][0] * 1000) / 1000);
                plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA);
                plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK);
                plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddC);
                plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddChi2);

                String roiName = name + "_Ch" + ch + "_cycle" + cycle + "_" + nameROI;
                updateFitResults(cycle, roiColumnName, aColumnName, bColumnName, cColumnName, Chi2ColumnName, roiName, fitAndPara[1][0][0], fitAndPara[1][1][0], fitAndPara[1][2][0], fitAndPara[1][3][0], fitAndPara[1][4][0]);
            }
            //residuals plot
            Plot plotResiduals = new Plot("residuals", xLabel, yLabel);
            plotResiduals.add("circles", x, yResiduals);
            if (pwin2 == null) {
                pwin2 = plotResiduals.show();
            } else {
                pwin2.drawPlot(plotResiduals);
            }
        }
        if (pwin == null) {
            pwin = plot.show();
        } else {
            pwin.drawPlot(plot);
        }
        String xColumnName = name + "_Ch" + ch + "_Z" + zPos + "_sec";
        String yColumnName = name + "_Ch" + ch + "_mean" + "_" + nameROI;
        String rTableName = name.substring(0, name.indexOf(".")) + "_results.csv";
        updateResultsTable(xColumnName, yColumnName, x, yOrig);
    }

    // returns true if there is a line or area selection
    void isSelection() {
        if (img == null) {
            IJ.showMessage("No images open", "Can't find the image");
            isSelection = false;
            return;
        }
        Roi roi = img.getRoi();
        if (roi == null) {
            isSelection = false;
            return;
        }
        int roiType = roi.getType();
        if (roiType <= Roi.FREELINE) {
            isSelection = true;
        } else {
            isSelection = false;
        }
    }

    // stop listening for mouse and key events if the plot window has been closed
    void checkPlotWindow() {
        if (pwin == null) {
            return;
        }
        if (pwin.isVisible()) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        canvas = iwin.getCanvas();
        canvas.removeMouseListener(this);
        canvas.removeMouseMotionListener(this);
        canvas.removeKeyListener(this);
        pwin = null;
        pwin2 = null;
        listenersRemoved = true;
    }

    public void keyReleased(KeyEvent e) {
    }

    public void keyPressed(KeyEvent e) {
    }

    public void keyTyped(KeyEvent e) {
    }

    public void mouseDragged(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }

    public void mouseClicked(MouseEvent e) {
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseMoved(MouseEvent e) {
    }

    public void mousePressed(MouseEvent e) {
    }

    private void updateResultsTable(String xColumnHeading, String yColumnHeading, double[] valuesX, double[] valuesY) {
        rt = Analyzer.getResultsTable();
        for (int i = 0; i < valuesX.length; i++) {
            rt.setValue(xColumnHeading, i, valuesX[i]);
            rt.setValue(yColumnHeading, i, valuesY[i]);
        }
        rt.show("Results");
        rt.updateResults();
    }

    private void updateFitResults(int row, String ROIColumnHeading, String aColumnHeading, String bColumnHeading, String cColumnHeading, String Chi2ColumnHeading, String ROI, double valuesA, double valuesK, double valuesC, double valuesR2, double valuesChi2) {
        rt = Analyzer.getResultsTable();
        rt.setNaNEmptyCells(true);
        if (!rt.columnExists(ROIColumnHeading)) {
            rt.setValue(ROIColumnHeading, row, ROI);
            rt.setValue(aColumnHeading, row, valuesA);
            rt.setValue(bColumnHeading, row, valuesK);
            rt.setValue(cColumnHeading, row, valuesC);
            rt.setValue(Chi2ColumnHeading, row, valuesChi2);
        } else if (rt.columnExists(ROIColumnHeading) && rt.size() - 1 <= row) {
            rt.setValue(ROIColumnHeading, row, ROI);
            rt.setValue(aColumnHeading, row, valuesA);
            rt.setValue(bColumnHeading, row, valuesK);
            rt.setValue(cColumnHeading, row, valuesC);
            rt.setValue(Chi2ColumnHeading, row, valuesChi2);
        } else if (rt.columnExists(ROIColumnHeading) && rt.size() - 1 > row) {
            boolean matchOrIndexFound = false;
            for (int i = 0; i < rt.size(); i++) {
                if (rt.getStringValue(ROIColumnHeading, i).equals(ROI)) {
                    matchOrIndexFound = true;
                    rt.setValue(ROIColumnHeading, i, ROI);
                    rt.setValue(aColumnHeading, i, valuesA);
                    rt.setValue(bColumnHeading, i, valuesK);
                    rt.setValue(cColumnHeading, i, valuesC);
                    rt.setValue(Chi2ColumnHeading, row, valuesChi2);
                }
                if (!matchOrIndexFound && rt.getStringValue(ROIColumnHeading, i).equals("NaN") && !rt.getStringValue(ROIColumnHeading, i - 1).equals("NaN")) {
                    matchOrIndexFound = true;
                    rt.setValue(ROIColumnHeading, i, ROI);
                    rt.setValue(aColumnHeading, i, valuesA);
                    rt.setValue(bColumnHeading, i, valuesK);
                    rt.setValue(cColumnHeading, i, valuesC);
                    rt.setValue(Chi2ColumnHeading, row, valuesChi2);
                }
            }
        }
        rt.show("Results");
        rt.updateResults();
    }

    private double[][][] updateCurveFit(double[] xCF, double[] yCF) {
        CurveFitter cf = new CurveFitter(xCF, yCF);
        double firstframeint = yCF[0];
        double lastframeint = yCF.length - 1;
        double guess_a = firstframeint - lastframeint;
        double guess_b = 1 / (guess_a * 0.37);
        double guess_c = lastframeint;
        double maxiteration = 2000;
        double NumRestarts = 2;
        double errotTol = 10;
        double[] fitparam = {
            guess_a,
            guess_b,
            guess_c,
            maxiteration,
            NumRestarts,
            errotTol
        };

        cf.setInitialParameters(fitparam);
        cf.doFit(11); //exponential decay with offset 
        double[] fittedParam = cf.getParams();
        double R2 = cf.getRSquared();
        double[] residuals = cf.getResiduals();
        double Chi2 = calculateReducedChi2(residuals, yCF);
        double[] theFit = getTheFit(fittedParam, cf.getXPoints());
        double[][][] theFitAndParameters = new double[theFit.length][theFit.length][theFit.length];
        for (int i = 0; i < theFit.length; i++) {
            theFitAndParameters[0][i][0] = theFit[i];
            theFitAndParameters[2][0][i] = residuals[i];
        }
        theFitAndParameters[1][0][0] = fittedParam[0];//a
        theFitAndParameters[1][1][0] = fittedParam[1];//b rate constant	
        theFitAndParameters[1][2][0] = fittedParam[2];//c offset
        theFitAndParameters[1][3][0] = R2;//r-squared
        theFitAndParameters[1][4][0] = Chi2;//reduced Chi-square

        return theFitAndParameters;
    }

    private double[] getTheFit(double[] fitParameters, double[] timePoints) {
        double[] theFit = new double[timePoints.length];
        for (int tp = 0; tp < timePoints.length; tp++) {
            theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2];
        }
        return theFit;
    }

    public double calculateReducedChi2(double[] residualArray, double[] dataArray) {
        double chi2ToReturn = 0;
        int dataPoints = 0;
        double[] residualArray2 = multiplyTwoArrays(residualArray, residualArray);
        double sum = 0;
        for(int s=residualArray2.length-estimateS2-1;s<residualArray2.length;s++){
            sum+=residualArray2[s];
        }
        double s2=sum/(estimateS2-1);
        double[] arrayToSum = divideTwoArrays(residualArray2, dataArray);
        for (int tp = 0; tp < arrayToSum.length; tp++) {
            if (!Double.isInfinite(arrayToSum[tp])) {
                chi2ToReturn = chi2ToReturn + arrayToSum[tp];
                dataPoints++;
            }
        }
        return chi2ToReturn / (dataPoints - 3 - 1);//divide by number of data points minus number of fitting parameters minus one
    }

    private double[] getTimingPerPlane(String arg, int tPoints, int currZ, int currCh) throws Exception {
    String fExt = arg.substring(arg.indexOf("."), arg.length());
	    if(fExt.contains(" ") && fExt.indexOf(" ")<arg.length())
	    	fExt = fExt.substring(0, fExt.indexOf(" "));
	    String id2 = arg.substring(0, arg.indexOf("."))+fExt;
	    double[] timeStampsToReturn = new double[tPoints];
	    IFormatReader reader = null;
	    int series = 0;
	try{
    	ServiceFactory factory = new ServiceFactory();
     	OMEXMLService service = factory.getInstance(OMEXMLService.class);
    	IMetadata meta = service.createOMEXMLMetadata();
    	// create format reader
    	reader = new ImageReader();
    	reader.setMetadataStore(meta);
     	// initialize file
    	reader.setId(id2);
        
    	int seriesCount = reader.getSeriesCount();
			
	   if (series < seriesCount) 
	    	reader.setSeries(series);
	    series = reader.getSeries();
	    int planeCount = meta.getPlaneCount(series);
		int tCounter=0;
	    for (int i = 0; i < planeCount; i++) {
	      Time deltaT = meta.getPlaneDeltaT(series, i);
	      if (deltaT == null) continue;
	      // convert plane ZCT coordinates into image plane index
	      int z = meta.getPlaneTheZ(series, i).getValue();
	      int c = meta.getPlaneTheC(series, i).getValue();
	      int t = meta.getPlaneTheT(series, i).getValue();
	        if(z==currZ && c==currCh){
	        	timeStampsToReturn[tCounter] = deltaT.value(UNITS.SECOND).doubleValue();
	        	tCounter++;
	        }
	    }
        if(planeCount==0){
        	GenericDialog gd2 = new GenericDialog("Problem with metadata");
        	gd2.addMessage("Time information from metadata was not found");
        	gd2.addMessage("Would you like to enter the time interval manually?");
        	gd2.addNumericField("Time between images in seconds", 0.050, 3);
			gd2.showDialog();
				if(gd2.wasCanceled())
					return null;
        	double userDeltaT = gd2.getNextNumber();
	        for(int t=0; t<timeStampsToReturn.length;t++){
	        	timeStampsToReturn[t] = t*userDeltaT;
	        }
        }	    
		} catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
        return timeStampsToReturn;
  }

    private static double[] subtractArrayFromArray(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - array2[i];
        }
        return arrayToReturn;

    }

    private static double[] multiplyTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] * array2[i];
        }
        return arrayToReturn;
    }

    private static double[] divideTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] / array2[i];
        }
        return arrayToReturn;
    }

    private static double[] subtractValueFromArray(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - theValue;
        }
        return arrayToReturn;
    }

    private static double[][] copyRange2DArray(double[][] srcArray, int srcPos0, int length) {
        double[] desArray0 = Arrays.copyOfRange(srcArray[0], srcPos0, srcPos0 + length);
        double[] desArray1 = Arrays.copyOfRange(srcArray[1], srcPos0, srcPos0 + length);
        double[][] returnArray = {desArray0, desArray1};
        return returnArray;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        Object ae = e.getSource();
        if (ae == getProfile) {
            img = WindowManager.getCurrentImage();
            profileGet = true;
            ImageProcessor ip2 = img.getProcessor();
            runIP(ip2);
        }
        if (ae == numCyclesTF) {
            numCycles = Integer.parseInt(numCyclesTF.getText());
        }
        if (ae == imagesPerCycleTF) {
            imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        }
        if (ae == checkCF) {
            if (checkCF.isSelected()) {
                fitCurves = true;
            }
            if (!checkCF.isSelected()) {
                fitCurves = false;
            }
        }
        if (ae == checkBkg) {
            if (checkBkg.isSelected()) {
                bkGrdSubtract = true;
            }
            if (!checkBkg.isSelected()) {
                bkGrdSubtract = false;
            }
        }

        if (ae == comboBoxDataList) {
            JComboBox cb = (JComboBox) e.getSource();
            bkGrdImage = (String) cb.getSelectedItem();
        }

        if (ae == checkProfilingOn) {
            if (checkProfilingOn.isSelected()) {
                ProfilingOn = true;
            }
            if (!checkProfilingOn.isSelected()) {
                ProfilingOn = false;
            }
        }
        if (ae == writeToResults) {
            img = WindowManager.getCurrentImage();
            saveResultsToTable = true;
            ImageProcessor ip3 = img.getProcessor();
            runIPandSave(ip3);
        }
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
 
    }

    @Override
    public void windowOpened(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowClosing(WindowEvent e) {
    }

    @Override
    public void windowClosed(WindowEvent e) {
        pluginWindowOpen = false;
        bkGrdSubtract = false;
        ProfilingOn = false;
        fitCurves = false;
    }

    @Override
    public void windowIconified(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowDeiconified(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowActivated(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowDeactivated(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void run(String arg) {
        if (IJ.versionLessThan("1.31i")) {
            return;
        }
        img = WindowManager.getCurrentImage();
        if (img == null) {
            IJ.showMessage("No images open", "Please open a stack for this operation");
            rMan = RoiManager.getRoiManager();
            rMan.runCommand("Show All");
            psFRET_T_Profiler psT = new psFRET_T_Profiler();
            psT.setVisible(true);
        } else {
            this.img = img;
            rMan = RoiManager.getRoiManager();
            rMan.runCommand("Show All");
            psFRET_T_Profiler psT = new psFRET_T_Profiler();
            psT.setVisible(true);
        }
    }
}
