/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
import ij.*;
import ij.plugin.*;
import ij.plugin.filter.Analyzer;
import ij.process.*;
import ij.gui.*;
import ij.util.Tools;
import java.awt.*;
import java.awt.event.*;
import java.util.*;
import ij.measure.*;
import java.awt.Rectangle;


import ij.WindowManager;

import ij.plugin.frame.RoiManager;

import java.io.IOException;
import java.awt.event.ActionEvent;
import java.awt.event.ActionListener;
import java.awt.event.WindowEvent;
import java.awt.event.WindowListener;
import java.awt.event.ItemEvent;

import javax.swing.JComboBox;
import javax.swing.DefaultComboBoxModel;
import java.beans.PropertyChangeListener;
import java.beans.PropertyChangeEvent;
import loci.common.services.ServiceFactory;
import loci.formats.IFormatReader;
import loci.formats.ImageReader;
import loci.formats.meta.IMetadata;
import loci.formats.services.OMEXMLService;

import ome.units.quantity.Time;
import ome.units.UNITS;
/**
 *
 * @author pattersg
 */
public class psFRET_T_Profiler extends javax.swing.JFrame implements UserFunction, PlugIn, MouseListener, MouseMotionListener, Measurements, KeyListener, ActionListener, PropertyChangeListener, WindowListener {
ImagePlus img;
    ImageCanvas canvas;
    ImageStatistics stats;
    PlotWindow pwin;
    PlotWindow pwin2;
    public double[] y;
    public double[] x;
    String xLabel;
    String yLabel;
    boolean listenersRemoved;
    boolean isSelection;
    private static int numCycles;
    private static int imagesPerCycle;
    private static boolean fitCurves;
    private static boolean bkGrdSubtract;
    private static boolean ProfilingOn;
    private static String bkGrdImage;
    private static boolean dialogCanceled;
    private static boolean profileGet;
    private static boolean pluginWindowOpen;
    private static boolean fitSingle;
    private static boolean fitDouble;
    private static boolean fitTriple;
    private static boolean showFitSettings;

    RoiManager rMan;
    ResultsTable rt;
    DefaultComboBoxModel dataListModel;
    Vector dataList = new Vector();
    /**
     * Creates new form psFRET_T_Profiler
     */
    public psFRET_T_Profiler() {
        initComponents();
        dataList.add("None");
        dataListModel = new DefaultComboBoxModel(dataList);
        comboBoxDataList.setModel(dataListModel);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        getProfile = new javax.swing.JButton();
        numCyclesTF = new javax.swing.JTextField();
        imagesPerCycleTF = new javax.swing.JTextField();
        numCycleText = new javax.swing.JLabel();
        imagesPerCycleText = new javax.swing.JLabel();
        checkCF = new javax.swing.JCheckBox();
        checkProfilingOn = new javax.swing.JCheckBox();
        writeToResults = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        checkBkg = new javax.swing.JCheckBox();
        bkGrdText = new javax.swing.JLabel();
        comboBoxDataList = new javax.swing.JComboBox<>();
        checkFitSingle = new javax.swing.JCheckBox();
        checkFitDouble = new javax.swing.JCheckBox();
        checkFitTriple = new javax.swing.JCheckBox();
        checkShowFitSettings = new javax.swing.JCheckBox();

        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);
        setTitle("psFRET T Profiler");

        getProfile.setText("Get Profile");
        getProfile.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                getProfileActionPerformed(evt);
            }
        });

        numCyclesTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        numCyclesTF.setText("3");
        numCyclesTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                numCyclesTFActionPerformed(evt);
            }
        });
        numCyclesTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                numCyclesTFPropertyChange(evt);
            }
        });

        imagesPerCycleTF.setHorizontalAlignment(javax.swing.JTextField.TRAILING);
        imagesPerCycleTF.setText("300");
        imagesPerCycleTF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                imagesPerCycleTFActionPerformed(evt);
            }
        });
        imagesPerCycleTF.addPropertyChangeListener(new java.beans.PropertyChangeListener() {
            public void propertyChange(java.beans.PropertyChangeEvent evt) {
                imagesPerCycleTFPropertyChange(evt);
            }
        });

        numCycleText.setText("Number of Cycles");

        imagesPerCycleText.setText("Images per Cycle");

        checkCF.setText("Run curve fits?");
        checkCF.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkCFItemStateChanged(evt);
            }
        });
        checkCF.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkCFActionPerformed(evt);
            }
        });

        checkProfilingOn.setText("Turn on dynamic profiling?");
        checkProfilingOn.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkProfilingOnItemStateChanged(evt);
            }
        });
        checkProfilingOn.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkProfilingOnActionPerformed(evt);
            }
        });

        writeToResults.setText("Write to Results");
        writeToResults.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                writeToResultsActionPerformed(evt);
            }
        });

        checkBkg.setText("Background subtract?");
        checkBkg.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkBkgItemStateChanged(evt);
            }
        });

        bkGrdText.setText("Choose the background data");

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(jPanel1Layout.createSequentialGroup()
                .addGap(35, 35, 35)
                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(bkGrdText)
                    .addComponent(checkBkg))
                .addContainerGap(47, Short.MAX_VALUE))
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()
                .addGap(27, 27, 27)
                .addComponent(checkBkg)
                .addGap(18, 18, 18)
                .addComponent(bkGrdText)
                .addContainerGap(20, Short.MAX_VALUE))
        );

        comboBoxDataList.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Item 1", "Item 2", "Item 3", "Item 4" }));
        comboBoxDataList.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                comboBoxDataListItemStateChanged(evt);
            }
        });

        checkFitSingle.setText("Fit single");
        checkFitSingle.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkFitSingleItemStateChanged(evt);
            }
        });
        checkFitSingle.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkFitSingleActionPerformed(evt);
            }
        });

        checkFitDouble.setText("Fit double");
        checkFitDouble.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkFitDoubleItemStateChanged(evt);
            }
        });
        checkFitDouble.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkFitDoubleActionPerformed(evt);
            }
        });

        checkFitTriple.setText("Fit triple");
        checkFitTriple.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkFitTripleItemStateChanged(evt);
            }
        });
        checkFitTriple.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkFitTripleActionPerformed(evt);
            }
        });

        checkShowFitSettings.setText("Show fit Settings?");
        checkShowFitSettings.addItemListener(new java.awt.event.ItemListener() {
            public void itemStateChanged(java.awt.event.ItemEvent evt) {
                checkShowFitSettingsItemStateChanged(evt);
            }
        });
        checkShowFitSettings.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkShowFitSettingsActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(35, 35, 35)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(0, 0, Short.MAX_VALUE)
                        .addComponent(checkShowFitSettings)
                        .addGap(88, 88, 88))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(checkCF, javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                                .addGap(9, 9, 9)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(numCycleText)
                                    .addComponent(imagesPerCycleText))
                                .addGap(18, 18, 18)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)
                                    .addComponent(imagesPerCycleTF)
                                    .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, 69, javax.swing.GroupLayout.PREFERRED_SIZE))))
                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(48, 48, 48)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                            .addComponent(checkFitSingle, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkFitDouble, javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(checkFitTriple, javax.swing.GroupLayout.Alignment.LEADING))
                        .addGap(0, 0, Short.MAX_VALUE))))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(comboBoxDataList, javax.swing.GroupLayout.PREFERRED_SIZE, 228, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(19, 19, 19))
            .addGroup(layout.createSequentialGroup()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGap(73, 73, 73)
                        .addComponent(getProfile))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(31, 31, 31)
                        .addComponent(checkProfilingOn))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(51, 51, 51)
                        .addComponent(writeToResults))
                    .addGroup(layout.createSequentialGroup()
                        .addContainerGap()
                        .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addGap(0, 0, Short.MAX_VALUE))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addComponent(getProfile)
                .addGap(18, 18, 18)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(numCyclesTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(numCycleText))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(imagesPerCycleText)
                    .addComponent(imagesPerCycleTF, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(checkCF)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkFitSingle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkFitDouble)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkFitTriple)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(checkShowFitSettings)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jPanel1, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(comboBoxDataList, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(38, 38, 38)
                .addComponent(checkProfilingOn)
                .addGap(31, 31, 31)
                .addComponent(writeToResults)
                .addContainerGap(36, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void getProfileActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_getProfileActionPerformed
        numCycles = Integer.parseInt(numCyclesTF.getText());
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
        img = WindowManager.getCurrentImage();
        profileGet = true;
        ImageProcessor ip2 = img.getProcessor();
        runIP(ip2);
    }//GEN-LAST:event_getProfileActionPerformed

    private void numCyclesTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_numCyclesTFActionPerformed
        numCycles = Integer.parseInt(numCyclesTF.getText());
    }//GEN-LAST:event_numCyclesTFActionPerformed

    private void imagesPerCycleTFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_imagesPerCycleTFActionPerformed
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
    }//GEN-LAST:event_imagesPerCycleTFActionPerformed

    private void checkCFActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkCFActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkCFActionPerformed

    private void checkProfilingOnActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkProfilingOnActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkProfilingOnActionPerformed

    private void writeToResultsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_writeToResultsActionPerformed
        img = WindowManager.getCurrentImage();
        profileGet = true;
        ImageProcessor ip3 = img.getProcessor();
        runIPandSave(ip3);
    }//GEN-LAST:event_writeToResultsActionPerformed

    private void numCyclesTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_numCyclesTFPropertyChange
        numCycles = Integer.parseInt(numCyclesTF.getText());
    }//GEN-LAST:event_numCyclesTFPropertyChange

    private void imagesPerCycleTFPropertyChange(java.beans.PropertyChangeEvent evt) {//GEN-FIRST:event_imagesPerCycleTFPropertyChange
        imagesPerCycle = Integer.parseInt(imagesPerCycleTF.getText());
    }//GEN-LAST:event_imagesPerCycleTFPropertyChange

    private void checkCFItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkCFItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitCurves = true;
            checkFitSingle.setSelected(true);
        } else {
            fitCurves = false;
            checkFitSingle.setSelected(false);
            checkFitDouble.setSelected(false);
            checkFitTriple.setSelected(false);
        }
    }//GEN-LAST:event_checkCFItemStateChanged

    private void checkBkgItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkBkgItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            rt = Analyzer.getResultsTable();
            String[] tableHeadings = rt.getHeadings();
            for (int th = 0; th < tableHeadings.length; th++) {
                if (dataListModel.getIndexOf(tableHeadings[th]) == -1) {
                    dataListModel.addElement(tableHeadings[th]);
                }
            }
            if (tableHeadings.length == 0) {
                IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table\nPlease use the 'Write To Results' button and try again");
                checkBkg.setSelected(false);
                return;
            }else{
            bkGrdSubtract = true;
            }
        } else {
            dataListModel.removeAllElements();
            dataListModel.addElement("None");
            bkGrdSubtract = false;
        }
    }//GEN-LAST:event_checkBkgItemStateChanged

    private void comboBoxDataListItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_comboBoxDataListItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            String bkGrdImageCB = (String) evt.getItem();
            bkGrdImage = bkGrdImageCB;
        }
    }//GEN-LAST:event_comboBoxDataListItemStateChanged

    private void checkProfilingOnItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkProfilingOnItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            ProfilingOn = true;
        } else {
            ProfilingOn = false;
        }
    }//GEN-LAST:event_checkProfilingOnItemStateChanged

    private void checkFitDoubleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkFitDoubleActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkFitDoubleActionPerformed

    private void checkFitTripleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkFitTripleActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkFitTripleActionPerformed

    private void checkFitSingleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkFitSingleItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitSingle = true;
            fitDouble = false;
            checkFitDouble.setSelected(false);
            fitTriple = false;
            checkFitTriple.setSelected(false);
        } 
    }//GEN-LAST:event_checkFitSingleItemStateChanged

    private void checkFitSingleActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkFitSingleActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkFitSingleActionPerformed

    private void checkFitDoubleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkFitDoubleItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitSingle = false;
            checkFitSingle.setSelected(false);
            fitDouble = true;
            fitTriple = false;
            checkFitTriple.setSelected(false);
        } 
    }//GEN-LAST:event_checkFitDoubleItemStateChanged

    private void checkFitTripleItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkFitTripleItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            fitSingle = false;
            checkFitSingle.setSelected(false);
            fitDouble = false;
            checkFitDouble.setSelected(false);
            fitTriple = true;
        } 
    }//GEN-LAST:event_checkFitTripleItemStateChanged

    private void checkShowFitSettingsItemStateChanged(java.awt.event.ItemEvent evt) {//GEN-FIRST:event_checkShowFitSettingsItemStateChanged
        if (evt.getStateChange() == ItemEvent.SELECTED) {
            showFitSettings = true;
        }else{
            showFitSettings = false;
        } 

    }//GEN-LAST:event_checkShowFitSettingsItemStateChanged

    private void checkShowFitSettingsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkShowFitSettingsActionPerformed
        // TODO add your handling code here:
    }//GEN-LAST:event_checkShowFitSettingsActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(psFRET_T_Profiler.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        new ij.ImageJ();
        
        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new psFRET_T_Profiler().setVisible(true);
                pluginWindowOpen=true;
            }
        });
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel bkGrdText;
    private javax.swing.JCheckBox checkBkg;
    private javax.swing.JCheckBox checkCF;
    private javax.swing.JCheckBox checkFitDouble;
    private javax.swing.JCheckBox checkFitSingle;
    private javax.swing.JCheckBox checkFitTriple;
    private javax.swing.JCheckBox checkProfilingOn;
    private javax.swing.JCheckBox checkShowFitSettings;
    private javax.swing.JComboBox<String> comboBoxDataList;
    private javax.swing.JButton getProfile;
    private javax.swing.JTextField imagesPerCycleTF;
    private javax.swing.JLabel imagesPerCycleText;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JLabel numCycleText;
    private javax.swing.JTextField numCyclesTF;
    private javax.swing.JButton writeToResults;
    // End of variables declaration//GEN-END:variables
   
    public void runIP(ImageProcessor ip) {
        if (dialogCanceled) {
            return;
        }
        ImagePlus img = WindowManager.getCurrentImage();
        this.img = img;
        if (img.getStackSize() < 2) {
            IJ.showMessage("psFRET T Profiler", "This command requires a stack.");
            return;
        }
        isSelection();
        if (!isSelection) {
            IJ.showMessage("psFRET T Profiler", "Selection required. Please make an ROI on the image.");
            return;
        }
        String filePath = IJ.getDirectory("image");
        String name = img.getTitle();
        String id = filePath + name;
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        if (numCycles * imagesPerCycle > size) {
            IJ.showMessage("psFRET T Profiler", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
        if (bkGrdSubtract && "None".equals(bkGrdImage)) {
            IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table\nPlease use the 'Write To Results' button and try again");
            return;
        }
        double[] timeData = new double[size];
        try {
            timeData = getTimingPerPlane(id, size, currentZ, currentchannel);
        } catch (Exception e) {
            e.printStackTrace();
        }
        IJ.resetMinAndMax(img);
        rMan = RoiManager.getRoiManager();
        ImageWindow win = img.getWindow();
        win.addWindowListener(win);
        canvas = win.getCanvas();
        canvas.addMouseListener(this);
        canvas.addMouseMotionListener(this);
        canvas.addKeyListener(this);
        Roi roi = img.getRoi();
        y = getTAxisProfile();
        if (y != null) {
            x = new double[y.length];
            Calibration cal = img.getCalibration();
            for (int i = 0; i < x.length; i++) {
                x[i] = timeData[i];
            }
            xLabel = cal.getTimeUnit();
            yLabel = cal.getValueUnit();
            updateProfile(x, y);
            profileGet = false;
            positionPlotWindow();
        }
    }

    public void runIPandSave(ImageProcessor ip) {
        if (dialogCanceled) {
            return;
        }
        img = WindowManager.getCurrentImage();
        this.img = img;
        if (img.getStackSize() < 2) {
            IJ.showMessage("psFRET T Profiler", "This command requires a stack.");
            return;
        }
        String filePath = IJ.getDirectory("image");
        String name = img.getTitle();
        String id = filePath + name;
        String ROIName = "";
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        if (numCycles * imagesPerCycle > size) {
            IJ.showMessage("psFRET T Profiler", "The number of cycles multiplied by the number images per cycle is larger than the stack");
            return;
        }
        if (bkGrdSubtract && "None".equals(bkGrdImage)) {
            IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
            return;
        }
        rMan = RoiManager.getRoiManager();
        if (rMan.getCount() == 0) {
            IJ.showMessage("psFRET T Profiler", "You must add at least one ROI to the ROI Manager to set results to the results table");
            return;
        }
        double[] timeData = new double[size];
        try {
            timeData = getTimingPerPlane(id, size, currentZ, currentchannel);
        } catch (Exception e) {
            e.printStackTrace();
        }
        IJ.resetMinAndMax(img);

        rMan.runCommand("Select All");
        rMan.runCommand("Save", filePath + name.substring(0, name.indexOf(".")) + "_RoiSet.zip");
        Roi[] roiArray = rMan.getRoisAsArray();
        for (int r = 0; r < roiArray.length; r++) {
            int roiIndex = rMan.getRoiIndex(roiArray[r]);
            rMan.select(img, roiIndex);
            ROIName = rMan.getName(roiIndex);
            Roi roi = img.getRoi();
            y = getTAxisProfile();
            if (y != null) {
                x = new double[y.length];
                Calibration cal = img.getCalibration();
                for (int i = 0; i < x.length; i++) {
                    x[i] = timeData[i];
                }
                xLabel = cal.getTimeUnit();
                yLabel = cal.getValueUnit();
                updateProfileAndResults(x, y, ROIName);
                profileGet = false;
                positionPlotWindow();
            }
        }
    }

    double[] getTAxisProfile() {
        ImageStack stack = img.getStack();
        Roi roi = img.getRoi();
        if (roi == null) {
            return null;
        }
        int nSlices = img.getNSlices();
        int size = img.getNFrames();
        if (size == 1)//in case the stack is read as a Z stack instead of T stack
        {
            size = nSlices;
        }
        int currentchannel = img.getC() - 1;
        int currentZ = img.getZ() - 1;
        double[] values = new double[size];
        Rectangle r = roi.getBoundingRect();
        Calibration cal = img.getCalibration();
        //ROI with Area > 0
        img.setC(currentchannel + 1);
        for (int i = 1; i <= size; i++) {
            if (img.getNFrames() == 1) {
                img.setZ(i);
            } else {
                img.setT(i);
            }
            ImageProcessor ip = img.getProcessor();
            ip.setRoi(roi);
            ImageStatistics stats = ImageStatistics.getStatistics(ip, MEAN, cal);
            values[i - 1] = (double) stats.mean;
        }
        if (img.getNFrames() == 1) {
            img.setZ(1);
        } else {
            img.setT(1);
        }
        double[] extrema = Tools.getMinMax(values);
        if (Math.abs(extrema[1]) == Double.MAX_VALUE) {
            return null;
        } else {
            return values;
        }
    }

    void positionPlotWindow() {
        IJ.wait(500);
        if (pwin == null || img == null) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        Dimension screen = Toolkit.getDefaultToolkit().getScreenSize();
        Dimension plotSize = pwin.getSize();
        Dimension imageSize = iwin.getSize();
        if (plotSize.width == 0 || imageSize.width == 0) {
            return;
        }
        Point imageLoc = iwin.getLocation();
        int w = imageLoc.x + imageSize.width + 10;
        if (w + plotSize.width > screen.width) {
            w = screen.width - plotSize.width;
        }
        pwin.setLocation(w, imageLoc.y);
        iwin.toFront();
    }

    public void mouseReleased(MouseEvent e) {
        checkPlotWindow();
        if (pwin != null && ProfilingOn) {
            y = getTAxisProfile();
            updateProfile(x, y);
        }
    }

    void updateProfile(double[] x, double[] y) {
        ImageStack stack = img.getStack();
        isSelection();
        if (!isSelection) {
            return;
        }
        checkPlotWindow();
        if (profileGet || ProfilingOn) {
            listenersRemoved = false;
        } else if (pwin == null || listenersRemoved || y == null || y.length == 0 || !ProfilingOn || !pluginWindowOpen) {
            return;
        }
        String name = img.getTitle();
        int ch = img.getC();
        int zPos = img.getZ();
        int n = img.getNFrames();
        Plot plot = new Plot("profile", xLabel, yLabel);
        double ymin = ProfilePlot.getFixedMin();
        double ymax = ProfilePlot.getFixedMax();
        if (!(ymin == 0.0 && ymax == 0.0)) {
            double[] a = Tools.getMinMax(x);
            double xmin = a[0];
            double xmax = a[1];
            plot.setLimits(xmin, xmax, ymin, ymax);
        }
        if (!fitCurves) {
            double[] x4Plot = new double [numCycles*imagesPerCycle];
            double[] y4Plot = new double [numCycles*imagesPerCycle];
            System.arraycopy(x, 0, x4Plot, 0, x4Plot.length);
            System.arraycopy(y, 0, y4Plot, 0, y4Plot.length);
            plot.add("circles", x4Plot, y4Plot);            
        }
        if (fitCurves) {
            if (bkGrdSubtract) {
                if ("None".equals(bkGrdImage) || bkGrdImage == null) {
                    IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
                    return;
                }
                rt = Analyzer.getResultsTable();
                double[] y2 = new double[y.length];
                for (int bkg = 0; bkg < y.length; bkg++) {
                    y2[bkg] = y[bkg] - rt.getValue(bkGrdImage, bkg);
                }
                y = y2;
            }
            double[] x4Plot = new double [numCycles*imagesPerCycle];
            double[] y4Plot = new double [numCycles*imagesPerCycle];
            System.arraycopy(x, 0, x4Plot, 0, x4Plot.length);
            System.arraycopy(y, 0, y4Plot, 0, y4Plot.length);
            plot.add("circles", x4Plot, y4Plot);
            double[] yResiduals = new double[y4Plot.length];
            for (int cycle = 0; cycle < numCycles; cycle++) {
                double[] x4Fit = Arrays.copyOfRange(x, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[] x4FitZerod = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    x4FitZerod[j] = x4Fit[j] - x4Fit[0];
                }
                double[] y4Fit = Arrays.copyOfRange(y, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[][][] fitAndPara = updateCurveFit(x4FitZerod, y4Fit);
                double[] yFitted = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    yFitted[j] = fitAndPara[0][j][0];
                    yResiduals[(cycle * imagesPerCycle) + j] = fitAndPara[2][0][j];
                }
                plot.add("line", x4Fit, yFitted);
                if (fitTriple) {
                    double wmk = ((fitAndPara[1][0][0]*fitAndPara[1][1][0])+(fitAndPara[1][2][0]*fitAndPara[1][3][0])+(fitAndPara[1][4][0]*fitAndPara[1][5][0]))/(fitAndPara[1][0][0]+fitAndPara[1][2][0]+fitAndPara[1][4][0]);
                    String labelToAddA1 = "A1=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k1=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddA2 = "A2=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                    String labelToAddK2 = "k2=" + String.valueOf((double) Math.round(fitAndPara[1][3][0] * 1000) / 1000);
                    String labelToAddA3 = "A3=" + String.valueOf((double) Math.round(fitAndPara[1][4][0] * 1000) / 1000);
                    String labelToAddK3 = "k3=" + String.valueOf((double) Math.round(fitAndPara[1][5][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    String labelToAddWMK = "WMK=" + String.valueOf((double) Math.round(wmk * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddA2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddK2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.3, labelToAddA3);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.35, labelToAddK3);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.4, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.45, labelToAddChi2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.5, labelToAddWMK);

                } else if (fitDouble) {
                    double wmk = ((fitAndPara[1][0][0]*fitAndPara[1][1][0])+(fitAndPara[1][2][0]*fitAndPara[1][3][0]))/(fitAndPara[1][0][0]+fitAndPara[1][2][0]);
                    String labelToAddA1 = "A1=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k1=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddA2 = "A2=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                    String labelToAddK2 = "k2=" + String.valueOf((double) Math.round(fitAndPara[1][3][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    String labelToAddWMK = "WMK=" + String.valueOf((double) Math.round(wmk * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddA2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddK2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.3, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.35, labelToAddChi2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.4, labelToAddWMK);

                } else {
                    String labelToAddA1 = "A=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddChi2);
                }
            }
           //residuals plot
            Plot plotResiduals = new Plot("residuals", xLabel, yLabel);
            plotResiduals.add("circles", x4Plot, yResiduals);
             if (pwin2 == null) {
                pwin2 = plotResiduals.show();
            } else {
                pwin2.drawPlot(plotResiduals);
            }
        }
        if (pwin == null) {
            pwin = plot.show();
        } else {
            pwin.drawPlot(plot);
        }
    }

    void updateProfileAndResults(double[] x, double[] y, String nameROI) {
        double[] yOrig = y;
        ImageStack stack = img.getStack();
        isSelection();
        if (!isSelection) {
            return;
        }
        checkPlotWindow();
        if (profileGet || ProfilingOn) {
            listenersRemoved = false;
        } else if (listenersRemoved || y == null || y.length == 0 || !pluginWindowOpen) {
            return;
        }
        String name = img.getTitle();
        int ch = img.getC();
        int zPos = img.getZ();
        int n = img.getNFrames();
        Plot plot = new Plot("profile", xLabel, yLabel);
        double ymin = ProfilePlot.getFixedMin();
        double ymax = ProfilePlot.getFixedMax();
        if (!(ymin == 0.0 && ymax == 0.0)) {
            double[] a = Tools.getMinMax(x);
            double xmin = a[0];
            double xmax = a[1];
            plot.setLimits(xmin, xmax, ymin, ymax);
        }
        if (!fitCurves) {
            double[] x4Plot = new double [numCycles*imagesPerCycle];
            double[] y4Plot = new double [numCycles*imagesPerCycle];
            System.arraycopy(x, 0, x4Plot, 0, x4Plot.length);
            System.arraycopy(y, 0, y4Plot, 0, y4Plot.length);
            plot.add("circles", x4Plot, y4Plot);
        }
        String roiColumnName = "Rois";
        String a1ColumnName = "a1_from_fit";
        String k1ColumnName = "k1_from_fit";
        String a2ColumnName = "a2_from_fit";
        String k2ColumnName = "k2_from_fit";
        String a3ColumnName = "a3_from_fit";
        String k3ColumnName = "k3_from_fit";
        String oColumnName = "offset_from_fit";
        String Chi2ColumnName = "Chi2_from_fit";
        String WMKColumnName = "WMK_from_fit";//weighted mean rate constant

        if (fitCurves) {
            if (bkGrdSubtract) {
                if ("None".equals(bkGrdImage) || bkGrdImage == null) {
                    IJ.showMessage("psFRET T Profiler", "Background subtraction requires selection of background data from the results table");
                    return;
                }
                rt = Analyzer.getResultsTable();
                double[] y2 = new double[y.length];
                for (int bkg = 0; bkg < y.length; bkg++) {
                    y2[bkg] = y[bkg] - rt.getValue(bkGrdImage, bkg);
                }
                y = y2;
            }
            double[] x4Plot = new double [numCycles*imagesPerCycle];
            double[] y4Plot = new double [numCycles*imagesPerCycle];
            System.arraycopy(x, 0, x4Plot, 0, x4Plot.length);
            System.arraycopy(y, 0, y4Plot, 0, y4Plot.length);
            plot.add("circles", x4Plot, y4Plot);
            double[] yResiduals = new double[y4Plot.length];
            for (int cycle = 0; cycle < numCycles; cycle++) {
                double[] x4Fit = Arrays.copyOfRange(x, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[] x4FitZerod = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    x4FitZerod[j] = x4Fit[j] - x4Fit[0];
                }
                double[] y4Fit = Arrays.copyOfRange(y, cycle * imagesPerCycle, ((cycle + 1) * imagesPerCycle));
                double[][][] fitAndPara = updateCurveFit(x4FitZerod, y4Fit);
                double[] yFitted = new double[x4Fit.length];
                for (int j = 0; j < x4Fit.length; j++) {
                    yFitted[j] = fitAndPara[0][j][0];
                    yResiduals[(cycle * imagesPerCycle) + j] = fitAndPara[2][0][j];
                }
                plot.add("line", x4Fit, yFitted);
                double wmk = Double.NaN;
                if (fitTriple) {
                    wmk = ((fitAndPara[1][0][0]*fitAndPara[1][1][0])+(fitAndPara[1][2][0]*fitAndPara[1][3][0])+(fitAndPara[1][4][0]*fitAndPara[1][5][0]))/(fitAndPara[1][0][0]+fitAndPara[1][2][0]+fitAndPara[1][4][0]);
                    String labelToAddA1 = "A1=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k1=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddA2 = "A2=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                    String labelToAddK2 = "k2=" + String.valueOf((double) Math.round(fitAndPara[1][3][0] * 1000) / 1000);
                    String labelToAddA3 = "A3=" + String.valueOf((double) Math.round(fitAndPara[1][4][0] * 1000) / 1000);
                    String labelToAddK3 = "k3=" + String.valueOf((double) Math.round(fitAndPara[1][5][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    String labelToAddWMK = "WMK=" + String.valueOf((double) Math.round(wmk * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddA2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddK2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.3, labelToAddA3);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.35, labelToAddK3);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.4, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.45, labelToAddChi2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.5, labelToAddWMK);

                } else if (fitDouble) {
                    wmk = ((fitAndPara[1][0][0]*fitAndPara[1][1][0])+(fitAndPara[1][2][0]*fitAndPara[1][3][0]))/(fitAndPara[1][0][0]+fitAndPara[1][2][0]);
                    String labelToAddA1 = "A1=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k1=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddA2 = "A2=" + String.valueOf((double) Math.round(fitAndPara[1][2][0] * 1000) / 1000);
                    String labelToAddK2 = "k2=" + String.valueOf((double) Math.round(fitAndPara[1][3][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    String labelToAddWMK = "WMK=" + String.valueOf((double) Math.round(wmk * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddA2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddK2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.3, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.35, labelToAddChi2);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.4, labelToAddWMK);

                } else {
                    String labelToAddA1 = "A=" + String.valueOf((double) Math.round(fitAndPara[1][0][0] * 1000) / 1000);
                    String labelToAddK1 = "k=" + String.valueOf((double) Math.round(fitAndPara[1][1][0] * 1000) / 1000);
                    String labelToAddOffset = "offset=" + String.valueOf((double) Math.round(fitAndPara[1][6][0] * 1000) / 1000);
                    String labelToAddChi2 = "Chi2=" + String.valueOf((double) Math.round(fitAndPara[1][7][0] * 1000) / 1000);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.1, labelToAddA1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.15, labelToAddK1);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.2, labelToAddOffset);
                    plot.addLabel(cycle * 0.35 + 0.05, 0.25, labelToAddChi2);
                }
                String roiName = name + "_Ch" + ch + "_cycle" + cycle + "_" + nameROI;
                updateFitResults(cycle, roiColumnName, a1ColumnName, k1ColumnName, a2ColumnName, k2ColumnName, a3ColumnName, k3ColumnName, oColumnName, Chi2ColumnName, WMKColumnName, roiName, fitAndPara[1][0][0], fitAndPara[1][1][0], fitAndPara[1][2][0], fitAndPara[1][3][0], fitAndPara[1][4][0], fitAndPara[1][5][0], fitAndPara[1][6][0], fitAndPara[1][7][0], wmk);
            }
            //residuals plot
            Plot plotResiduals = new Plot("residuals", xLabel, yLabel);
            plotResiduals.add("circles", x4Plot, yResiduals);
            if (pwin2 == null) {
                pwin2 = plotResiduals.show();
            } else {
                pwin2.drawPlot(plotResiduals);
            }
        }
        if (pwin == null) {
            pwin = plot.show();
        } else {
            pwin.drawPlot(plot);
        }
        String xColumnName = name + "_Ch" + ch + "_Z" + zPos + "_sec";
        String yColumnName = name + "_Ch" + ch + "_mean" + "_" + nameROI;
        String rTableName = name.substring(0, name.indexOf(".")) + "_results.csv";
        updateResultsTable(xColumnName, yColumnName, x, yOrig);
    }

    // returns true if there is a line or area selection
    void isSelection() {
        if (img == null) {
            IJ.showMessage("No images open", "Can't find the image");
            isSelection = false;
            return;
        }
        Roi roi = img.getRoi();
        if (roi == null) {
            isSelection = false;
            return;
        }
        int roiType = roi.getType();
        if (roiType <= Roi.FREELINE) {
            isSelection = true;
        } else {
            isSelection = false;
        }
    }

    // stop listening for mouse and key events if the plot window has been closed
    void checkPlotWindow() {
        if (pwin == null) {
            return;
        }
        if (pwin.isVisible()) {
            return;
        }
        ImageWindow iwin = img.getWindow();
        if (iwin == null) {
            return;
        }
        canvas = iwin.getCanvas();
        canvas.removeMouseListener(this);
        canvas.removeMouseMotionListener(this);
        canvas.removeKeyListener(this);
        pwin = null;
        pwin2 = null;
        listenersRemoved = true;
    }

    public void keyReleased(KeyEvent e) {
    }

    public void keyPressed(KeyEvent e) {
    }

    public void keyTyped(KeyEvent e) {
    }

    public void mouseDragged(MouseEvent e) {
    }

    public void mouseExited(MouseEvent e) {
    }

    public void mouseClicked(MouseEvent e) {
    }

    public void mouseEntered(MouseEvent e) {
    }

    public void mouseMoved(MouseEvent e) {
    }

    public void mousePressed(MouseEvent e) {
    }

    private void updateResultsTable(String xColumnHeading, String yColumnHeading, double[] valuesX, double[] valuesY) {
        rt = Analyzer.getResultsTable();
        for (int i = 0; i < valuesX.length; i++) {
            rt.setValue(xColumnHeading, i, valuesX[i]);
            rt.setValue(yColumnHeading, i, valuesY[i]);
        }
        rt.show("Results");
        rt.updateResults();
    }

    private void updateFitResults(int row, String ROIColumnHeading, String a1ColumnHeading, String k1ColumnHeading, String a2ColumnHeading, String k2ColumnHeading, String a3ColumnHeading, String k3ColumnHeading, String oColumnHeading, String Chi2ColumnHeading,  String WMKColumnHeading, String ROI, double valuesA1, double valuesK1, double valuesA2, double valuesK2, double valuesA3, double valuesK3, double valuesOffset, double valuesChi2, double valuesWMK) {
        rt = Analyzer.getResultsTable();
        rt.setNaNEmptyCells(true);
        if (!rt.columnExists(ROIColumnHeading)) {
            rt.setValue(ROIColumnHeading, row, ROI);
            rt.setValue(a1ColumnHeading, row, valuesA1);
            rt.setValue(k1ColumnHeading, row, valuesK1);
            rt.setValue(a2ColumnHeading, row, valuesA2);
            rt.setValue(k2ColumnHeading, row, valuesK2);
            rt.setValue(a3ColumnHeading, row, valuesA3);
            rt.setValue(k3ColumnHeading, row, valuesK3);
            rt.setValue(oColumnHeading, row, valuesOffset);
            rt.setValue(Chi2ColumnHeading, row, valuesChi2);
            rt.setValue(WMKColumnHeading, row, valuesWMK);
        } else if (rt.columnExists(ROIColumnHeading) && rt.size() - 1 <= row) {
            rt.setValue(ROIColumnHeading, row, ROI);
            rt.setValue(a1ColumnHeading, row, valuesA1);
            rt.setValue(k1ColumnHeading, row, valuesK1);
            rt.setValue(a2ColumnHeading, row, valuesA2);
            rt.setValue(k2ColumnHeading, row, valuesK2);
            rt.setValue(a3ColumnHeading, row, valuesA3);
            rt.setValue(k3ColumnHeading, row, valuesK3);
            rt.setValue(oColumnHeading, row, valuesOffset);
            rt.setValue(Chi2ColumnHeading, row, valuesChi2);
            rt.setValue(WMKColumnHeading, row, valuesWMK);
        } else if (rt.columnExists(ROIColumnHeading) && rt.size() - 1 > row) {
            boolean matchOrIndexFound = false;
            for (int i = 0; i < rt.size(); i++) {
                if (rt.getStringValue(ROIColumnHeading, i).equals(ROI)) {
                    matchOrIndexFound = true;
                    rt.setValue(ROIColumnHeading, i, ROI);
                    rt.setValue(a1ColumnHeading, i, valuesA1);
                    rt.setValue(k1ColumnHeading, i, valuesK1);
                    rt.setValue(a2ColumnHeading, i, valuesA2);
                    rt.setValue(k2ColumnHeading, i, valuesK2);
                    rt.setValue(a3ColumnHeading, i, valuesA3);
                    rt.setValue(k3ColumnHeading, i, valuesK3);
                    rt.setValue(oColumnHeading, i, valuesOffset);
                    rt.setValue(Chi2ColumnHeading, i, valuesChi2);
                    rt.setValue(WMKColumnHeading, i, valuesWMK);
                }
                if (!matchOrIndexFound && rt.getStringValue(ROIColumnHeading, i).equals("NaN") && !rt.getStringValue(ROIColumnHeading, i - 1).equals("NaN")) {
                    matchOrIndexFound = true;
                    rt.setValue(ROIColumnHeading, i, ROI);
                    rt.setValue(a1ColumnHeading, i, valuesA1);
                    rt.setValue(k1ColumnHeading, i, valuesK1);
                    rt.setValue(a2ColumnHeading, i, valuesA2);
                    rt.setValue(k2ColumnHeading, i, valuesK2);
                    rt.setValue(a3ColumnHeading, i, valuesA3);
                    rt.setValue(k3ColumnHeading, i, valuesK3);
                    rt.setValue(oColumnHeading, i, valuesOffset);
                    rt.setValue(Chi2ColumnHeading, i, valuesChi2);
                    rt.setValue(WMKColumnHeading, i, valuesWMK);
                }
            }
        }
        rt.show("Results");
        rt.updateResults();
    }

    private double[][][] updateCurveFit(double[] xCF, double[] yCF) {
        CurveFitter cf = new CurveFitter(xCF, yCF);
        double firstframeint = yCF[0];
        double lastframeint = yCF.length - 1;
        double[][][] theFitAndParameters = new double[xCF.length][xCF.length][xCF.length];
        
        double tau = findTauEstimate(xCF, yCF, firstframeint, lastframeint);
        
        if(fitTriple){
        String fitFunction = "y = a*exp(-bx) + c*exp(-dx) + e*exp(-fx) + g";
        double guess_a1 = firstframeint - lastframeint;
        double guess_k1 = 1 / tau;
        double guess_a2 = (firstframeint - lastframeint)/5;
        double guess_k2 = (1 / tau)/10;
        double guess_a3 = (firstframeint - lastframeint)/10;
        double guess_k3 = (1 / tau)/20;
        double guess_o = lastframeint;
        double maxiteration = 2000;
        double NumRestarts = 2;
        double errotTol = 10;
        double[] fitparam = {
            guess_a1,
            guess_k1,
            guess_a2,
            guess_k2,
            guess_a3,
            guess_k3,
            guess_o,
            maxiteration,
            NumRestarts,
            errotTol
        };
        double[] initialParaVara = divideArrayByValue(fitparam,10);
        cf.doCustomFit(this, 7, fitFunction,  fitparam, initialParaVara, showFitSettings); //triple exponential decay with offset 
        double[] fittedParam = cf.getParams();
        double[] residuals = cf.getResiduals();
        double[] theFit = getTheFit(fittedParam, cf.getXPoints());
        double Chi2 = calculateChi2(residuals, theFit);
        for (int i = 0; i < theFit.length; i++) {
            theFitAndParameters[0][i][0] = theFit[i];
            theFitAndParameters[2][0][i] = residuals[i];
        }
        theFitAndParameters[1][0][0] = fittedParam[0];//a1
        theFitAndParameters[1][1][0] = fittedParam[1];//k1 rate constant	
        theFitAndParameters[1][2][0] = fittedParam[2];//a2 
        theFitAndParameters[1][3][0] = fittedParam[3];//k2 rate constant
        theFitAndParameters[1][4][0] = fittedParam[4];//a3 	
        theFitAndParameters[1][5][0] = fittedParam[5];//k3 rate constant
        theFitAndParameters[1][6][0] = fittedParam[6];//offset
        theFitAndParameters[1][7][0] = Chi2;//reduced Chi-square    
        
        }else if (fitDouble){
        String fitFunction = "y = a*exp(-bx) + c*exp(-dx) + e";
        double guess_a1 = (firstframeint - lastframeint)/2;
        double guess_k1 = 1 / tau;
        double guess_a2 = (firstframeint - lastframeint)/2;
        double guess_k2 = (1 / tau)/10;
        double guess_o = lastframeint;
        double maxiteration = 2000;
        double NumRestarts = 2;
        double errotTol = 10;
        double[] fitparam = {
            guess_a1,
            guess_k1,
            guess_a2,
            guess_k2,
            guess_o,
            maxiteration,
            NumRestarts,
            errotTol
        };
        double[] initialParaVara = divideArrayByValue(fitparam,10);
        cf.doCustomFit(this, 5, fitFunction,  fitparam, initialParaVara, showFitSettings); //double exponential decay with offset 
        double[] fittedParam = cf.getParams();
        double[] residuals = cf.getResiduals();
        double[] theFit = getTheFit(fittedParam, cf.getXPoints());
        double Chi2 = calculateChi2(residuals, theFit);
        for (int i = 0; i < theFit.length; i++) {
            theFitAndParameters[0][i][0] = theFit[i];
            theFitAndParameters[2][0][i] = residuals[i];
        }
        theFitAndParameters[1][0][0] = fittedParam[0];//a1
        theFitAndParameters[1][1][0] = fittedParam[1];//k1 rate constant	
        theFitAndParameters[1][2][0] = fittedParam[2];//a2 
        theFitAndParameters[1][3][0] = fittedParam[3];//k2 rate constant
        theFitAndParameters[1][6][0] = fittedParam[4];//offset
        theFitAndParameters[1][7][0] = Chi2;//reduced Chi-square        
        
        }else{
            
        double guess_a1 = firstframeint - lastframeint;
        double guess_k1 = 1 / tau;
        double guess_o = lastframeint;
        double maxiteration = 2000;
        double NumRestarts = 2;
        double errotTol = 10;
        double[] fitparam = {
            guess_a1,
            guess_k1,
            guess_o,
            maxiteration,
            NumRestarts,
            errotTol
        };

        cf.setInitialParameters(fitparam);
        cf.doFit(11); //single exponential decay with offset 
        double[] fittedParam = cf.getParams();
        double[] residuals = cf.getResiduals();
        double[] theFit = getTheFit(fittedParam, cf.getXPoints());
        double Chi2 = calculateChi2(residuals, theFit);
        for (int i = 0; i < theFit.length; i++) {
            theFitAndParameters[0][i][0] = theFit[i];
            theFitAndParameters[2][0][i] = residuals[i];
        }
        theFitAndParameters[1][0][0] = fittedParam[0];//a
        theFitAndParameters[1][1][0] = fittedParam[1];//b rate constant	
        theFitAndParameters[1][6][0] = fittedParam[2];//c offset
        theFitAndParameters[1][7][0] = Chi2;//reduced Chi-square
        }

        return theFitAndParameters;
    }
    
    public double findTauEstimate(double[] x, double[] y, double startIntensity, double endIntensity){
        double tauToReturn = 1;
        double previousIntensity = startIntensity-endIntensity;
        for(int t=0; t<y.length;t++){
            if((y[t]-endIntensity) <= ((startIntensity-endIntensity)*0.37) && previousIntensity >= ((startIntensity-endIntensity)*0.37))
                tauToReturn = x[t];
           previousIntensity = y[t]-endIntensity;
        }
        return tauToReturn;
    }
  
    @Override
    public double userFunction(double[] par, double x) {
        if (fitTriple) {
            return par[0] * Math.exp(-par[1] * x) + par[2] * Math.exp(-par[3] * x) + par[4] * Math.exp(-par[5] * x) + par[6];
        }else if (fitDouble) {
            return par[0] * Math.exp(-par[1] * x) + par[2] * Math.exp(-par[3] * x) + par[4];
        }
        return par[0] * Math.exp(-par[1] * x) + par[2];
    }

    private double[] getTheFit(double[] fitParameters, double[] timePoints) {
        double[] theFit = new double[timePoints.length];
        for (int tp = 0; tp < timePoints.length; tp++) {
            if(fitTriple)
                theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2] * Math.exp(-fitParameters[3] * timePoints[tp]) + fitParameters[4] * Math.exp(-fitParameters[5] * timePoints[tp]) + fitParameters[6];
            else if(fitDouble)
                theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2] * Math.exp(-fitParameters[3] * timePoints[tp]) + fitParameters[4];
            else
                theFit[tp] = fitParameters[0] * Math.exp(-fitParameters[1] * timePoints[tp]) + fitParameters[2];
        }
        return theFit;
    }

    public double calculateChi2(double[] residualArray, double[] fitArray) {
        double chi2ToReturn = 0;
        double[] residualArray2 = multiplyTwoArrays(residualArray, residualArray);
        double[] arrayToSum = divideTwoArrays(residualArray2, fitArray);
        for (int tp = 0; tp < arrayToSum.length; tp++) {
            if (!Double.isInfinite(arrayToSum[tp])) {
                chi2ToReturn = chi2ToReturn + arrayToSum[tp];
            }
        }
        return chi2ToReturn;
    }
    
    public static double getMeanOfArray(double[] theArray) {
        double sum = 0;
        for (int i = 0; i < theArray.length; i++) {
            sum = sum + theArray[i];
        }
        return sum / theArray.length;
    }

    public static double getSumOfArray(double[] theArray) {
        double sum = 0;
        for (int i = 0; i < theArray.length; i++) {
            sum = sum + theArray[i];
        }
        return sum;
    }

    private double[] getTimingPerPlane(String arg, int tPoints, int currZ, int currCh) throws Exception {
        String fExt = arg.substring(arg.indexOf("."), arg.length());
        if (fExt.contains(" ") && fExt.indexOf(" ") < arg.length()) {
            fExt = fExt.substring(0, fExt.indexOf(" "));
        }
        String id2 = arg.substring(0, arg.indexOf(".")) + fExt;
        double[] timeStampsToReturn = new double[tPoints];
        IFormatReader reader = null;
        int series = 0;
        try {
            ServiceFactory factory = new ServiceFactory();
            OMEXMLService service = factory.getInstance(OMEXMLService.class);
            IMetadata meta = service.createOMEXMLMetadata();
            // create format reader
            reader = new ImageReader();
            reader.setMetadataStore(meta);
            // initialize file
            reader.setId(id2);

            int seriesCount = reader.getSeriesCount();

	   if (series < seriesCount) 
	    	reader.setSeries(series);
	    series = reader.getSeries();
	    int planeCount = meta.getPlaneCount(series);
		int tCounter=0;
	    for (int i = 0; i < planeCount; i++) {
	      Time deltaT = meta.getPlaneDeltaT(series, i);
	      if (deltaT == null) continue;
	      // convert plane ZCT coordinates into image plane index
	      int z = meta.getPlaneTheZ(series, i).getValue();
	      int c = meta.getPlaneTheC(series, i).getValue();
	      int t = meta.getPlaneTheT(series, i).getValue();
	        if(z==currZ && c==currCh){
	        	timeStampsToReturn[tCounter] = deltaT.value(UNITS.SECOND).doubleValue();
	        	tCounter++;
	        }
	    }
        if(planeCount==0){
        	GenericDialog gd2 = new GenericDialog("Problem with metadata");
        	gd2.addMessage("Time information from metadata was not found");
        	gd2.addMessage("Would you like to enter the time interval manually?");
        	gd2.addNumericField("Time between images in seconds", 0.050, 3);
			gd2.showDialog();
				if(gd2.wasCanceled())
					return null;
        	double userDeltaT = gd2.getNextNumber();
	        for(int t=0; t<timeStampsToReturn.length;t++){
	        	timeStampsToReturn[t] = t*userDeltaT;
	        }
        }	    
		} catch (IOException e) {
            e.printStackTrace();
        }finally {
            try {
                if (reader != null) {
                    reader.close();
                }
            } catch (IOException ex) {
                ex.printStackTrace();
            }
        }
        return timeStampsToReturn;
  }

    private static double[] subtractArrayFromArray(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - array2[i];
        }
        return arrayToReturn;

    }

    private static double[] multiplyTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] * array2[i];
        }
        return arrayToReturn;
    }

    private static double[] divideTwoArrays(double[] array1, double[] array2) {
        if (array1.length != array2.length) {
            IJ.showMessage("psFRET_T_Profiler", "The time and data arrays are not the same length");
            return null;
        }
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] / array2[i];
        }
        return arrayToReturn;
    }

    private static double[] subtractValueFromArray(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i] - theValue;
        }
        return arrayToReturn;
    }
    
    private static double[] divideArrayByValue(double[] array1, double theValue) {
        double[] arrayToReturn = new double[array1.length];
        for (int i = 0; i < array1.length; i++) {
            arrayToReturn[i] = array1[i]/theValue;
        }
        return arrayToReturn;
    }

    @Override
    public void actionPerformed(ActionEvent e) {
        
    }

    @Override
    public void propertyChange(PropertyChangeEvent evt) {
 
    }

    @Override
    public void windowOpened(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowClosing(WindowEvent e) {
    }

    @Override
    public void windowClosed(WindowEvent e) {
        pluginWindowOpen = false;
        bkGrdSubtract = false;
        ProfilingOn = false;
        fitCurves = false;
    }

    @Override
    public void windowIconified(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowDeiconified(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowActivated(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void windowDeactivated(WindowEvent e) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void run(String arg) {
        if (IJ.versionLessThan("1.31i")) {
            IJ.showMessage("ImageJ version", "Please upgrade ImageJ");
            return;
        }
        img = WindowManager.getCurrentImage();
        if (img == null) {
            IJ.showMessage("No images open", "Please open a stack for this operation");
            rMan = RoiManager.getRoiManager();
            rMan.runCommand("Show All");
            psFRET_T_Profiler psT = new psFRET_T_Profiler();
            psT.setVisible(true);
        } else {
            this.img = img;
            rMan = RoiManager.getRoiManager();
            rMan.runCommand("Show All");
            psFRET_T_Profiler psT = new psFRET_T_Profiler();
            psT.setVisible(true);
        }
    }
}
